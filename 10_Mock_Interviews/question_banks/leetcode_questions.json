{
  "questions": [
    {
      "id": "two_sum",
      "title": "Two Sum",
      "difficulty": "easy",
      "category": "arrays",
      "tags": ["arrays", "hashing"],
      "file_path": "03_Blind_75/Easy/01_Two_Sum.py",
      "description": "Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.",
      "examples": [
        {
          "input": "nums = [2,7,11,15], target = 9",
          "output": "[0,1]",
          "explanation": "Because nums[0] + nums[1] == 9, we return [0, 1]."
        }
      ],
      "constraints": [
        "2 <= nums.length <= 10^4",
        "-10^9 <= nums[i] <= 10^9",
        "-10^9 <= target <= 10^9",
        "Only one valid answer exists."
      ],
      "time_complexity": "O(n)",
      "space_complexity": "O(n)",
      "startup_friendly": true
    },
    {
      "id": "contains_duplicate",
      "title": "Contains Duplicate",
      "difficulty": "easy",
      "category": "arrays",
      "tags": ["arrays", "hashing"],
      "file_path": "03_Blind_75/Easy/02_Contains_Duplicate.py",
      "description": "Given an integer array nums, return true if any value appears at least twice in the array, and return false if every element is distinct.",
      "examples": [
        {
          "input": "nums = [1,2,3,1]",
          "output": "true"
        }
      ],
      "time_complexity": "O(n)",
      "space_complexity": "O(n)",
      "startup_friendly": true
    },
    {
      "id": "valid_anagram",
      "title": "Valid Anagram",
      "difficulty": "easy",
      "category": "strings",
      "tags": ["strings", "hashing", "sorting"],
      "file_path": "03_Blind_75/Easy/03_Valid_Anagram.py",
      "description": "Given two strings s and t, return true if t is an anagram of s, and false otherwise.",
      "examples": [
        {
          "input": "s = 'anagram', t = 'nagaram'",
          "output": "true"
        }
      ],
      "time_complexity": "O(n)",
      "space_complexity": "O(1)",
      "startup_friendly": true
    },
    {
      "id": "valid_palindrome",
      "title": "Valid Palindrome",
      "difficulty": "easy",
      "category": "strings",
      "tags": ["strings", "two-pointers"],
      "file_path": "03_Blind_75/Easy/05_Valid_Palindrome.py",
      "description": "A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward.",
      "examples": [
        {
          "input": "s = 'A man, a plan, a canal: Panama'",
          "output": "true"
        }
      ],
      "time_complexity": "O(n)",
      "space_complexity": "O(1)",
      "startup_friendly": true
    },
    {
      "id": "valid_parentheses",
      "title": "Valid Parentheses",
      "difficulty": "easy",
      "category": "stack",
      "tags": ["stack", "string"],
      "file_path": "03_Blind_75/Easy/08_Valid_Parentheses.py",
      "description": "Given a string s containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid.",
      "examples": [
        {
          "input": "s = '()'",
          "output": "true"
        }
      ],
      "time_complexity": "O(n)",
      "space_complexity": "O(n)",
      "startup_friendly": true
    },
    {
      "id": "binary_search",
      "title": "Binary Search",
      "difficulty": "easy",
      "category": "binary-search",
      "tags": ["binary-search", "arrays"],
      "file_path": "03_Blind_75/Easy/09_Binary_Search.py",
      "description": "Given an array of integers nums which is sorted in ascending order, and an integer target, write a function to search target in nums. If target exists, then return its index. Otherwise, return -1.",
      "examples": [
        {
          "input": "nums = [-1,0,3,5,9,12], target = 9",
          "output": "4"
        }
      ],
      "time_complexity": "O(log n)",
      "space_complexity": "O(1)",
      "startup_friendly": true
    },
    {
      "id": "reverse_linked_list",
      "title": "Reverse Linked List",
      "difficulty": "easy",
      "category": "linked-list",
      "tags": ["linked-list", "recursion"],
      "file_path": "03_Blind_75/Easy/10_Reverse_Linked_List.py",
      "description": "Given the head of a singly linked list, reverse the list, and return the reversed list.",
      "examples": [
        {
          "input": "head = [1,2,3,4,5]",
          "output": "[5,4,3,2,1]"
        }
      ],
      "time_complexity": "O(n)",
      "space_complexity": "O(1)",
      "startup_friendly": true
    },
    {
      "id": "max_depth_binary_tree",
      "title": "Maximum Depth of Binary Tree",
      "difficulty": "easy",
      "category": "trees",
      "tags": ["tree", "dfs", "recursion"],
      "file_path": "03_Blind_75/Easy/12_Maximum_Depth_of_Binary_Tree.py",
      "description": "Given the root of a binary tree, return its maximum depth.",
      "examples": [
        {
          "input": "root = [3,9,20,null,null,15,7]",
          "output": "3"
        }
      ],
      "time_complexity": "O(n)",
      "space_complexity": "O(h)",
      "startup_friendly": true
    },
    {
      "id": "best_time_buy_sell_stock",
      "title": "Best Time to Buy and Sell Stock",
      "difficulty": "easy",
      "category": "arrays",
      "tags": ["arrays", "dynamic-programming", "sliding-window"],
      "file_path": "03_Blind_75/Easy/03_Best_Time_to_Buy_and_Sell_Stock.py",
      "description": "You are given an array prices where prices[i] is the price of a given stock on the ith day. You want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock. Return the maximum profit you can achieve from this transaction.",
      "examples": [
        {
          "input": "prices = [7,1,5,3,6,4]",
          "output": "5",
          "explanation": "Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5."
        }
      ],
      "time_complexity": "O(n)",
      "space_complexity": "O(1)",
      "startup_friendly": true
    },
    {
      "id": "group_anagrams",
      "title": "Group Anagrams",
      "difficulty": "medium",
      "category": "arrays",
      "tags": ["arrays", "hashing", "strings"],
      "file_path": "03_Blind_75/Easy/04_Group_Anagrams.py",
      "description": "Given an array of strings strs, group the anagrams together. You can return the answer in any order.",
      "examples": [
        {
          "input": "strs = ['eat','tea','tan','ate','nat','bat']",
          "output": "[['bat'],['nat','tan'],['ate','eat','tea']]"
        }
      ],
      "time_complexity": "O(n*k)",
      "space_complexity": "O(n*k)",
      "startup_friendly": true
    },
    {
      "id": "maximum_subarray",
      "title": "Maximum Subarray",
      "difficulty": "medium",
      "category": "arrays",
      "tags": ["arrays", "dynamic-programming", "divide-and-conquer"],
      "file_path": "03_Blind_75/Easy/04_Maximum_Subarray.py",
      "description": "Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.",
      "examples": [
        {
          "input": "nums = [-2,1,-3,4,-1,2,1,-5,4]",
          "output": "6",
          "explanation": "[4,-1,2,1] has the largest sum = 6."
        }
      ],
      "time_complexity": "O(n)",
      "space_complexity": "O(1)",
      "startup_friendly": true
    },
    {
      "id": "merge_two_sorted_lists",
      "title": "Merge Two Sorted Lists",
      "difficulty": "easy",
      "category": "linked-list",
      "tags": ["linked-list", "recursion"],
      "file_path": "03_Blind_75/Easy/11_Merge_Two_Sorted_Lists.py",
      "description": "You are given the heads of two sorted linked lists list1 and list2. Merge the two lists in a sorted order.",
      "examples": [
        {
          "input": "list1 = [1,2,4], list2 = [1,3,4]",
          "output": "[1,1,2,3,4,4]"
        }
      ],
      "time_complexity": "O(n+m)",
      "space_complexity": "O(1)",
      "startup_friendly": true
    },
    {
      "id": "same_tree",
      "title": "Same Tree",
      "difficulty": "easy",
      "category": "trees",
      "tags": ["tree", "dfs", "recursion"],
      "file_path": "03_Blind_75/Easy/13_Same_Tree.py",
      "description": "Given the roots of two binary trees p and q, write a function to check if they are the same or not.",
      "examples": [
        {
          "input": "p = [1,2,3], q = [1,2,3]",
          "output": "true"
        }
      ],
      "time_complexity": "O(n)",
      "space_complexity": "O(h)",
      "startup_friendly": true
    }
  ]
}

